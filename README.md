Push_swap

[ 연결 리스트 ]
메모리 상에 연속적이지 않은 노드들을 포인터를 연결해 만든 자료구조
각 노드는 데이터와 다음 노드를 가리키는 포인터를 가진다.

칸 사이의 간격이 메모리 상에 띄엄띄엄 있어도 선로만 연결되어 있으면 전체가 하나로 이어진다.

배열처럼 연속된 공간 X, 필요할 때마다 malloc 으로 새로운 노드를 만들어야 한다,
그리고 이를 next 포인터로 연결한다.

기본 구성은 아래와 같다.

typedef struct Node {
    int data;        // 칸 안에 저장할 값	
    struct Node *next; // 다음 칸을 가리키는 포인터
} Node;

typedef struct 형태로 구조체를 만들고, 
안에 원하는 만큼의 필드를 만든 뒤, 다음 칸을 가리키는 포인터를 추가한다.


struct Node *head;
> typedef struct Node 구조체는 Node라는 별칭을 가지고 있고,
이 별칭으로 연결하지 않고, 기본적인 구조체 형식을 가져와 연결하고 있는 것.
head 포인터에 struct Node 를 연결함으로써, typedef struct Node 안에 있는 모든 필드들에 접근할 수 있다.

Node *head;
> 위와 완전히 동일함.


void push_front(Node **head, int value) {
    Node *n = malloc(sizeof(Node));
    n->data = value;
    n->next = *head;
    *head = n;
}

0. 파라미터에서 Node 형식으로 head를 이중포인터로, value를 정수형으로 받는다.
    이중 포인터  	> 함수 안에서 호출한 쪽의 head 변수 자체를 갱신(새 노드를 머리로)하기 위해서.
    value		> 노드 안에 있는 value를 저장하기 위해.

1. Node *n = malloc(sizeof(Node))
>> Node 구조체만큼 동적할당을 한다. 이를 노드 포인터 n에 저장하는 것.

n -> data = value;
n - > next = *head;
Node 구조체 형식으로 선언했던 n과 data를 연결한다. 그리고 이 값은 value다.
이전의 첫 번째 노드를 복사해서 n -> next에 저장한다. ( next는 문자와 전혀 관계가 없고,  )



*** 연결리스트를 잇는다 == 구조체의 틀을 만들고, 이를 여러 번 복사하여 그 안의 필드들을 사용하겠다는 뜻. ***

따라서 malloc을 각각 진행해야 하고,
포인터를 연결해야 하고, 
data 필드에 있는 값을 저장해서 계속 다음 칸으로 보내야 한다.









typedef struct Node{
    int data; // 저장할 실제 값
    struct Node *next; // 다음 노드의 주소(포인터)
} Node;

void stack_push(Node **top, int value) {
    Node *n = malloc(sizeof(Node));
    n->data = value;
    n->next = *top;
    *top = n;
}



함수의 signature 부터 짚어보면,

1. void stack_push(Node **top, int value);
> Node **top : 노드 포인터를 가리키는 포인터.


==========================================================================

스택 2개를 만들어
a, b를 구분한다


a에는 랜덤적으로 중복되지 않는 -/+ 정수형 데이터들이 들어있다.
b에는 아무것도 들어있지 않다.

목표는 a에 있는 숫자들을 정렬시키는 것.


sa : swap a - 스택 a의 가장 위에 있는 두 원소(혹은 첫 번째 원소와 두 번째 원소)의 위치를 서로 바꾼다.

sb : swap b - 스택 b의 가장 위에 있는 두 원소(혹은 첫 번째 원소와 두 번째 원소)의 위치를 서로 바꾼다.

ss : sa와 sb를 동시에 실행한다.

pa : push a - 스택 b에서 가장 위(탑)에 있는 원소를 가져와서, 스택 a의 맨 위(탑)에 넣는다. 스택 b가 비어 있으면 아무것도 하지 않는다.

pb : push b - 스택 a에서 가장 위(탑)에 있는 원소를 가져와서, 스택 b의 맨 위(탑)에 넣는다. 스택 a가 비어있으면 아무것도 하지 않는다.

ra : rotate a - 스택 a의 모든 원소들을 위로 1 인덱스만큼 올린다. 첫 번째 원소(탑)는 마지막 원소(바텀)가 된다.

rb : rotate b - 스택 b의 모든 원소들을 위로 1 인덱스만큼 올린다. 첫 번째 원소(탑)는 마지막 원소(바텀)가 된다.

rr : ra와 rb를 동시에 실행한다.

rra : reverse rotate a - 스택 a의 모든 원소들을 아래로 1 인덱스만큼 내린다. 마지막 원소(바텀)는 첫 번째 원소(탑)가 된다.

rrb : reverse rotate b - 스택 b의 모든 원소들을 아래로 1 인덱스만큼 내린다. 마지막 원소(바텀)는 첫 번째 원소(탑)가 된다.

rrr : rra와 rrb를 동시에 실행한다.


---===------===------===------===------===------===------===------===---

1. push_swap 프로그램 역할
입력: 커맨드라인 인수로 받은 스택 A(랜덤 정수들)
출력: A를 오름차순으로 만들기 위해 “어떤 명령어(sa,pb,ra,…)”를 써야 할지 계산해서 한 줄씩 출력
종료: 명령어를 모두 찍고 즉시 종료


2. 명령어를 “직접 입력”하는 건 checker
checker는 push_swap이 출력한 명령어를 표준입력으로 받아 스택 A/B에 적용해 보고
최종 결과가 맞으면 "OK"를, 아니면 "KO"를 출력


3. 정렬 조건
A의 최종 상태가 “오름차순(가장 작은 값이 맨 위)”이 돼야 합니다.
이 “오름차순”을 이루기 위해 사용할 수 있는 수단이 주어진 명령어들뿐입니다.
즉, qsort 같은 일반 함수나, 반복문에서 값을 직접 바꿔 치환하는 게 아니라
“push/pop/rotate” 연산만으로 스택 A를 정렬하는 로직을 짜야 합니다.

---===------===------===------===------===------===------===------===---

>>
***얼마나 명령어를 적게 사용해서 
a에 있는 데이터들을 모두 정렬할 수 있느냐***



프로젝트는 반드시 아래 규칙을 준수해야 합니다:
• Makefile을 제출해야 하며, 소스 파일만 컴파일하고 재링크하면 안 됩니다.
• 전역 변수 사용이 금지됩니다.
• push_swap이라는 이름의 프로그램을 작성해야 하며, 인수로 정수 리스트를 받아 스택 A를 구성합니다. 이때 첫 번째 인수가 스택의 맨 위가 되어야 합니다.
• 프로그램은 스택 A를 정렬하기 위한 최소 명령어 시퀀스를 출력해야 합니다.
• 명령어는 ‘\n’으로만 구분되어야 하며, 그 외 다른 출력은 없어야 합니다.
• 목표는 가능한 한 최소한의 연산 횟수로 스택을 정렬하는 것입니다. 평가 과정에서 출력된 명령어 수가 허용 한계를 넘거나 정렬이 올바르게 되지 않으면 점수는 0점입니다.
• 인수가 하나도 주어지지 않으면 아무 출력 없이 바로 종료해야 합니다.
• 에러가 발생하면 표준 오류(stderr)에 "Error\n"만을 출력해야 합니다.

예: 인수가 정수가 아니거나, 정수 범위를 초과하거나, 중복된 인자가 있을 경우



일반적인 push_front 방식으로 연결리스트 내부의 데이터를 채우고 출력하면
뒤집어져서 채워진다.

1 2 3 4 5
>>
 5
4
3
2
1
연결리스트는 null부터 탐색하기 때문, 재귀와 비슷함


[ 재귀 ]
void recurse(Node *p) {
    if (!p) return; 
    printf("%d ", p->data); 
    recurse(p->next);
}

[ 연결리스트 ]
typedef struct Node {
    int data;
    struct Node *next;
} Node;

(재귀) : printf 시 다음 데이터를 가리키고 있고, 그 데이터는 recurse 함수로 다시 들어가기 때문에 가장 안쪽을 먼저 출력한다.
		이후, unwind 되어 제일 안쪽 > 2번째 > 1번째 > ' ' ' 이런식으로 출력될 것임.

[프레임 A: recurse(node1)]
 └── calls →
     [프레임 B: recurse(node2)]
      └── calls →
          [프레임 C: recurse(node3)]
           └── calls →
               [프레임 D: recurse(NULL)] → 리턴
스택 언와인드:
 D 리턴 → C 리턴 → B 리턴 → A 리턴



(연결리스트 ): 재귀 스택이 쌓이는 것처럼, 노드블럭이 heap에 순서대로 연결되어 있다고 생각하면 된다.

헤드(head) ──▶ [A:data=1 | next──▶ B]
                        [B:data=2 | next──▶ C]
                        [C:data=3 | next──▶ NULL]




push swap 에선 스택이라는 개념을 사용하지만,
지금까지 알아온 스택을 사용하지는 않음. 즉, 명시적으로 스택이라고 하는 가상의 공간인 것.

따라서 일반적인 방법으로 스택을 쌓을 경우 ( 연결리스트를 연결함과 동시에 데이터를 넣는 행위 ) 는
데이터가 뒤에서부터 저장되기 때문에, 이를 정상적으로 저장하는 방법을 찾아야 한다.
push_front -> push_back




-> 
화살표는 . 과 동일한 표현

(*n).next; 와
n -> next;
는 완전히 같은 표현임

포인터 n이 가리키는 Node 구조체 내부의 next 멤버를 뜻한다.





























































