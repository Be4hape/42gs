Push_swap

[ 연결 리스트 ]
메모리 상에 연속적이지 않은 노드들을 포인터를 연결해 만든 자료구조
각 노드는 데이터와 다음 노드를 가리키는 포인터를 가진다.

칸 사이의 간격이 메모리 상에 띄엄띄엄 있어도 선로만 연결되어 있으면 전체가 하나로 이어진다.

배열처럼 연속된 공간 X, 필요할 때마다 malloc 으로 새로운 노드를 만들어야 한다,
그리고 이를 next 포인터로 연결한다.

기본 구성은 아래와 같다.

typedef struct Node {
    int data;        // 칸 안에 저장할 값	
    struct Node *next; // 다음 칸을 가리키는 포인터
} Node;

typedef struct 형태로 구조체를 만들고, 
안에 원하는 만큼의 필드를 만든 뒤, 다음 칸을 가리키는 포인터를 추가한다.


struct Node *head;
> typedef struct Node 구조체는 Node라는 별칭을 가지고 있고,
이 별칭으로 연결하지 않고, 기본적인 구조체 형식을 가져와 연결하고 있는 것.
head 포인터에 struct Node 를 연결함으로써, typedef struct Node 안에 있는 모든 필드들에 접근할 수 있다.

Node *head;
> 위와 완전히 동일함.


void push_front(Node **head, int value) {
    Node *n = malloc(sizeof(Node));
    n->data = value;
    n->next = *head;
    *head = n;
}

0. 파라미터에서 Node 형식으로 head를 이중포인터로, value를 정수형으로 받는다.
    이중 포인터  	> 함수 안에서 호출한 쪽의 head 변수 자체를 갱신(새 노드를 머리로)하기 위해서.
    value		> 노드 안에 있는 value를 저장하기 위해.

1. Node *n = malloc(sizeof(Node))
>> Node 구조체만큼 동적할당을 한다. 이를 노드 포인터 n에 저장하는 것.

n -> data = value;
n - > next = *head;
Node 구조체 형식으로 선언했던 n과 data를 연결한다. 그리고 이 값은 value다.
이전의 첫 번째 노드를 복사해서 n -> next에 저장한다. ( next는 문자와 전혀 관계가 없고,  )



*** 연결리스트를 잇는다 == 구조체의 틀을 만들고, 이를 여러 번 복사하여 그 안의 필드들을 사용하겠다는 뜻. ***

따라서 malloc을 각각 진행해야 하고,
포인터를 연결해야 하고, 
data 필드에 있는 값을 저장해서 계속 다음 칸으로 보내야 한다.









typedef struct Node{
    int data; // 저장할 실제 값
    struct Node *next; // 다음 노드의 주소(포인터)
} Node;

void stack_push(Node **top, int value) {
    Node *n = malloc(sizeof(Node));
    n->data = value;
    n->next = *top;
    *top = n;
}



함수의 signature 부터 짚어보면,

1. void stack_push(Node **top, int value);
> Node **top : 노드 포인터를 가리키는 포인터.


==========================================================================

스택 2개를 만들어
a, b를 구분한다


a에는 랜덤적으로 중복되지 않는 -/+ 정수형 데이터들이 들어있다.
b에는 아무것도 들어있지 않다.

목표는 a에 있는 숫자들을 정렬시키는 것.


sa : swap a - 스택 a의 가장 위에 있는 두 원소(혹은 첫 번째 원소와 두 번째 원소)의 위치를 서로 바꾼다.

sb : swap b - 스택 b의 가장 위에 있는 두 원소(혹은 첫 번째 원소와 두 번째 원소)의 위치를 서로 바꾼다.

ss : sa와 sb를 동시에 실행한다.

pa : push a - 스택 b에서 가장 위(탑)에 있는 원소를 가져와서, 스택 a의 맨 위(탑)에 넣는다. 스택 b가 비어 있으면 아무것도 하지 않는다.

pb : push b - 스택 a에서 가장 위(탑)에 있는 원소를 가져와서, 스택 b의 맨 위(탑)에 넣는다. 스택 a가 비어있으면 아무것도 하지 않는다.

ra : rotate a - 스택 a의 모든 원소들을 위로 1 인덱스만큼 올린다. 첫 번째 원소(탑)는 마지막 원소(바텀)가 된다.

rb : rotate b - 스택 b의 모든 원소들을 위로 1 인덱스만큼 올린다. 첫 번째 원소(탑)는 마지막 원소(바텀)가 된다.

rr : ra와 rb를 동시에 실행한다.

rra : reverse rotate a - 스택 a의 모든 원소들을 아래로 1 인덱스만큼 내린다. 마지막 원소(바텀)는 첫 번째 원소(탑)가 된다.

rrb : reverse rotate b - 스택 b의 모든 원소들을 아래로 1 인덱스만큼 내린다. 마지막 원소(바텀)는 첫 번째 원소(탑)가 된다.

rrr : rra와 rrb를 동시에 실행한다.


---===------===------===------===------===------===------===------===---

프로젝트는 반드시 C로 작성되어야 합니다.
• 프로젝트는 Norm에 따라 작성되어야 합니다. 보너스 파일/함수도 Norm 검사에 포함되며, Norm 오류가 있을 경우 0점을 받습니다.
• 함수는 정의되지 않은 동작을 제외하고는 예기치 않게 종료(세그멘테이션 폴트, 버스 오류, 이중 해제 등)되어서는 안 되며, 이러한 오류 발생 시 프로젝트는 비기능적(0점)으로 간주됩니다.
• 모든 힙 할당 메모리는 필요할 때 적절히 해제되어야 합니다. 메모리 누수는 용납되지 않습니다.
• 과제에서 요구하는 경우, cc를 사용하여 -Wall, -Wextra, -Werror 플래그로 소스 파일을 컴파일하는 Makefile을 제출해야 하며, 불필요한 재링크를 수행해서는 안 됩니다.
• Makefile에는 최소한 $(NAME), all, clean, fclean, re 규칙이 포함되어야 합니다.
• 보너스를 제출하기 위해 Makefile에 bonus 규칙을 포함해야 하며, 이는 메인 파트에서 허용되지 않는 헤더, 라이브러리, 함수를 추가합니다. 보너스 코드는 _bonus.c/h 파일에 배치해야 합니다(과제에서 별도 명시하지 않는 한). 필수 및 보너스 평가는 별도로 진행됩니다.
• libft 사용이 허용되는 경우, libft 소스와 Makefile을 libft 폴더에 복사해야 합니다. 프로젝트 Makefile은 libft의 Makefile을 사용하여 라이브러리를 컴파일한 후 프로젝트를 빌드해야 합니다.
• 테스트 프로그램을 작성하는 것을 권장합니다. 이 테스트는 제출할 필요 없으며 평가되지 않지만, 과제 구현 및 동료 과제를 손쉽게 검증하는 데 유용합니다. 디펜스 시 자신 또는 동료의 테스트를 자유롭게 사용할 수 있습니다.
• 작업물을 지정된 Git 저장소에 제출해야 합니다. 저장소에 있는 작업만 채점됩니다. Deepthought가 채점에 사용되는 경우 동료 평가 이후 진행되며, 채점 중 오류 발생 시 평가가 중단됩니다.

1. push_swap 프로그램 역할
입력: 커맨드라인 인수로 받은 스택 A(랜덤 정수들)
출력: A를 오름차순으로 만들기 위해 “어떤 명령어(sa,pb,ra,…)”를 써야 할지 계산해서 한 줄씩 출력
종료: 명령어를 모두 찍고 즉시 종료


2. 명령어를 “직접 입력”하는 건 checker
checker는 push_swap이 출력한 명령어를 표준입력으로 받아 스택 A/B에 적용해 보고
최종 결과가 맞으면 "OK"를, 아니면 "KO"를 출력


3. 정렬 조건
A의 최종 상태가 “오름차순(가장 작은 값이 맨 위)”이 돼야 합니다.
이 “오름차순”을 이루기 위해 사용할 수 있는 수단이 주어진 명령어들뿐입니다.
즉, qsort 같은 일반 함수나, 반복문에서 값을 직접 바꿔 치환하는 게 아니라
“push/pop/rotate” 연산만으로 스택 A를 정렬하는 로직을 짜야 합니다.




프로젝트는 반드시 아래 규칙을 준수해야 합니다:
• Makefile을 제출해야 하며, 소스 파일만 컴파일하고 재링크하면 안 됩니다.
• 전역 변수 사용이 금지됩니다.
• push_swap이라는 이름의 프로그램을 작성해야 하며, 인수로 정수 리스트를 받아 스택 A를 구성합니다. 이때 첫 번째 인수가 스택의 맨 위가 되어야 합니다.
• 프로그램은 스택 A를 정렬하기 위한 최소 명령어 시퀀스를 출력해야 합니다.
• 명령어는 ‘\n’으로만 구분되어야 하며, 그 외 다른 출력은 없어야 합니다.
• 목표는 가능한 한 최소한의 연산 횟수로 스택을 정렬하는 것입니다. 평가 과정에서 출력된 명령어 수가 허용 한계를 넘거나 정렬이 올바르게 되지 않으면 점수는 0점입니다.
• 인수가 하나도 주어지지 않으면 아무 출력 없이 바로 종료해야 합니다.
• 에러가 발생하면 표준 오류(stderr)에 "Error\n"만을 출력해야 합니다.

예: 인수가 정수가 아니거나, 정수 범위를 초과하거나, 중복된 인자가 있을 경우


프로젝트 검증을 위한 벤치마크 요건은 다음과 같습니다:

100% 달성 및 보너스 자격

100개 랜덤 수를 700회 미만의 연산으로 정렬

500개 랜덤 수를 5500회 이하의 연산으로 정렬

최소 80% 검증 (최소 80점)
아래 세 가지 평균 조건 중 하나를 만족하면 됩니다:

100개 < 1100회 AND 500개 < 8500회

100개 < 700회 AND 500개 < 11500회

100개 < 1300회 AND 500개 < 5500회

모든 벤치마크는 평가 과정에서 자동으로 측정되며, 기준을 만족하지 못하면 해당 등급을 받을 수 없습니다.




---===------===------===------===------===------===------===------===---

>>
***얼마나 명령어를 적게 사용해서 
a에 있는 데이터들을 모두 정렬할 수 있느냐***






일반적인 push_front 방식으로 연결리스트 내부의 데이터를 채우고 출력하면
뒤집어져서 채워진다.

1 2 3 4 5
>>
 5
4
3
2
1
연결리스트는 null부터 탐색하기 때문, 재귀와 비슷함


[ 재귀 ]
void recurse(Node *p) {
    if (!p) return; 
    printf("%d ", p->data); 
    recurse(p->next);
}

[ 연결리스트 ]
typedef struct Node {
    int data;
    struct Node *next;
} Node;

(재귀) : printf 시 다음 데이터를 가리키고 있고, 그 데이터는 recurse 함수로 다시 들어가기 때문에 가장 안쪽을 먼저 출력한다.
		이후, unwind 되어 제일 안쪽 > 2번째 > 1번째 > ' ' ' 이런식으로 출력될 것임.

[프레임 A: recurse(node1)]
 └── calls →
     [프레임 B: recurse(node2)]
      └── calls →
          [프레임 C: recurse(node3)]
           └── calls →
               [프레임 D: recurse(NULL)] → 리턴
스택 언와인드:
 D 리턴 → C 리턴 → B 리턴 → A 리턴



(연결리스트 ): 재귀 스택이 쌓이는 것처럼, 노드블럭이 heap에 순서대로 연결되어 있다고 생각하면 된다.

헤드(head) ──▶ [A:data=1 | next──▶ B]
                        [B:data=2 | next──▶ C]
                        [C:data=3 | next──▶ NULL]




push swap 에선 스택이라는 개념을 사용하지만,
지금까지 알아온 스택을 사용하지는 않음. 즉, 명시적으로 스택이라고 하는 가상의 공간인 것.

따라서 일반적인 방법으로 스택을 쌓을 경우 ( 연결리스트를 연결함과 동시에 데이터를 넣는 행위 ) 는
데이터가 뒤에서부터 저장되기 때문에, 이를 정상적으로 저장하는 방법을 찾아야 한다.
push_front -> push_back




-> 
화살표는 . 과 동일한 표현

(*n).next; 와
n -> next;
는 완전히 같은 표현임

포인터 n이 가리키는 Node 구조체 내부의 next 멤버를 뜻한다.


###
exit > #include <stdlib.h>
 exit(), return() 차이 > exit은 프로그램을 종료하는 함수, return은 함수를 종료하는 함수. main에서 쓸 경우 두 함수는 동일하게 작동함 

exit 사용 시 > exit(0) 정상종료, exit(1) 비정상 종료.

= exit(EXIT_SUCCESS), exit(EXIT_FAILURE) 와 동일함.

###

-- 명령어 구현 완료 7.21.--


error1.0.1 
1 2 3 6 5 8 에서
pb를 연속적으로 실행 시, 
6 5 8
3 2 1
로 저장이 되어야 하는데, 

6 5 8
1 2 3
으로 저장이 되고 있음, >> 데이터를 저장할 때 뒤에서부터 채워넣는 방식을 사용하기 때문 and push 함수에서 단순하게 노드를 연결하는 일밖에 하지 않기 								
							때문


push 시, rotate같은 노드를 복합적으로 처리하는 게 필요함


-- fixed --


[ Big-O 표현 ]
(시간복잡도 관점에서 log n 은 
log와 n 사이에 10이 아닌 2가 있다, 
10의 지수가 아니라 2의 지수 형태로 표현된다.)

log 8 = 2^3 이므로 '3'
log 64 = 2^6 이므로 '6'




[ 기수 정렬 ] - radix sort

push_swap 과제에서 
100% : 100개의 입력, 700회 미만의 연산으로 정렬
		500개 입력, 5500회 미만의 연산으로 정렬

80% : 
100개 < 1100회 
500개 < 8500회

100개 < 700회
500개 < 11500회

100개 < 1300회 
500개 < 5500회

이기 때문에, 100%에 부합하기 위해서 radix sort를 사용한다.

radix sort의 시간복잡도 : n log n 이므로
n이 100일 때, 100 * log 100 이므로 

log 100 ~= 7 
>> 700

500 * 9 = 4500
>> 맞아 떨어짐

따라서 기수정렬을 채택한다. (radix sort, 자릿수마다 비교하여 수를 재배치함. 일의 자리 배치, 십의 자리 배치, 100의 자리 배치, ' ' ' )



1) LSD    (least significant digit) 제일 낮은 자리부터 차례로 정렬
2) MSD (most significant digit)  제일 높은 자리부터 차례로 정렬


이진 기수정렬,
10진 기수정렬


10진 기수정렬 : 10개의 bucket 을 만들어, 자릿 수 마다 검사하여 그 숫자에 맞는 버킷에 저장한다.
				이후, 숫자를 합친 뒤, 다음 자릿수를 검사하는데, 역시 버킷의 개수는 10개


2진 기수정렬    : 기존 10개에서 2개로 버킷의 개수가 바뀐 것. 이를 비트표현으로 하여 자릿수의 비트가 1이거나 0이라면 버킷에 넣는다 or 현상유지
				이후 숫자를 합치고, 다음 자릿수도 똑같이 진행

기수정렬을 사용하기 위해 2진 기수정렬이 움직이는 모양을 보고, 그 모양을 명령어를 여러번 사용하여 똑같이 구현하면 됨.
ex. 비트가 1인 경우 현상유지(ra. 다음 요소를 검사하기 위해), 비트가 0인 경우 pb로 옮긴다. 
	다시 합치는 과정 : pa

>> 모든 비트를 검사할 때까지 계속한다. 

2진 기수정렬로 진행하고, 특별한 상황에서, 굳이 정렬 알고리즘을  사용할 필요가 없는 부분에선 하드하게 명령어를 넣어서 실행한다.




정렬 시, 불필요하게 많이 반복하는 부분에서 
Tim sort 아이디어를 따와서 사용할 것.

tim sort : 정렬을 해야하는 전체 배열을 덩어리들로 잘라서 각각의 덩어리를 insertion 으로 정렬한 뒤, merge sort로 병합하면 빠를 것이다.




[ Parsing ]
argument 간 차이가 너무 큰 경우
>1 10000 10000000 
이런식으로 들어오면 2진 기수정렬을 사용 시, 불필요하게 많이 작동함.

위의 받아온 숫자를
1 2 3 
이런식으로 바꿔주는 처리를 하는게 좋을 것.




처음 argument를 받을 때, 

./push_swap 1 2 3 4 5 6 ' ' ' 
./push_swap "1 2 3 4 5 6 ' ' '   "

여러 인자로 받거나,
하나의 문자열에 스페이스로 묶여 들어올 수도 있음.



여러 인자로 받는다 > argument를 atoi로 바꾸어 연결리스트의 data field에 넣는다. 
하나의 문자열 안에 들어온다 > split으로 띄어쓰기를 구분해주고, atoi로 문자형태로 들어온 숫자들을 정수형으로 바꾼다.

만약,

1. "" > 비어있거나
2. "+" or "-" 를 허용하고, 나머지는 전부 0~9만 있어야 한다.
3. int를 벗어나거나, 중간에 문자가 나오면 안된다. > strtol(진수표현된 문자를 문자로 바꾸는 함수, 다른 모든 표현들에 대해서도 방어하기 위해 사용?
														long long OR unsigned long long으로 누적하면서 매 스텝마다 INT_MAX, INT_MIN check)
4. 중복된 숫자가 있는지.
5. 메모리 리소스 정리 > split 이후 free가 모두 정상적으로 이뤄졌는지. valgrind check 


long long : 8바이트
> int로 변환한 데이터가 최대 or 최소인 경우, 그 값들을 계속해서 더하며 판별할 예정이기 때문에 long long으로 선언해야함. 




-- zsh <> bash --

1. bash : ./push_swap $(shuf -i1-1000 -n100)
실행 시 자동으로 공백, 탭, 줄바꿈을 기준으로 split한다.
그 결과가 $1 $2 $3 ' ' ' #100 형태로 push_swap의 인자로 전달함.

2. zsh : shuf 출력 전체가 하나의 문자열로 묶여 push_swap에 인자 하나 $1= 1 237 45 ' ' ' 982 로 전달
push_swap 코드 상에서 인자가 하나라면 잘못된 입력이기 때문에, Error를 출력하는 것.




zsh에서 bash 처럼 사용하려면,
1. .zsh 파일 자체를 수정한다 >> echo "setopt SH_WORD_SPLIT" >> ~/.zshrc
'
'
'


결론적으로 bash는 커맨드 치환 후 IFS(공백, 탭, 줄바꿈) 기준을 삼아 자동으로 단어를 분리하는데
zsh는 단어를 분리하지 않고 하나의 문자열로 취급하기 때문에 일어나는 일.

따라서 zsh에서 bash와 같은 스크립트를 돌릴 때, 명시적으로 단어 분리를 해주면 정상작동 한다.




---------------7.27. 구현완료 ---------------

rotate, push 함수 말고 다른 함수에도 안전장치가 필요함,
makefile 만들어야 함.

여러 케이스 실험해보고 set finish,
파일 헷갈리지 말 것,



----------------7.28. find bug------------------

./push_swap 42
>> fail, introduction이 0개여야 하는데, 실행되고 있음

./push_swap 0 1 2 3
>> 아무것도 표시되지 않아야 하는데, 실행되고 있음

./push_swap 0 1 2 3 4 5 6 7 8 9
>> 아무것도 표시되지 않아야 하는데, 실행되고 있음

ARG="2 1 0"; ./push_swap $ARG | ./checker_linux $ARG
>> checker - OK, but 명령 목록 크기가 3이상임.

ARG="1 5 2 4 3"; ./push_swap $ARG | ./checker_linux $ARG
>> checker - ok, but 명령 목록 크기가 12 이상임, 8개일 시 KUDOS.

ARG="5 random values"; ./push_swap $ARG | checker_linux $ARG
>> 명령 목록의 크기가 12를 초과하지 않는지 확인해야 함. but, 초과함.


파싱한 값들을 비교하는 과정이 없고, 단순하게 비트로 쪼개어 pb와 ra를 반복하기 때문에, 
오름차순으로 이미 정렬되어 있는 케이스에 대해서는 알 수 없음.
> 따라서 다시 정렬하는 행위를 함


